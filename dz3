"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
from time import time
import locale

n = 10 ** 5

locale.setlocale(locale.LC_ALL, "ru.UTF-8")  # для  Windows
# locale.setlocale(locale.LC_ALL, ""ru_RU.UTF-8"")   # для MacOS


def time_decorator(func):
    def timer(*args, **kwargs):
        start = time()
        result = func(*args, **kwargs)
        end = time()
        print(f'Время выполенения  {func.__name__} ' 
              f'составило {end - start}')
        return result

    return timer


"""
a) Oценка:
   - заполнение списка из n элементов:  О(1) 
   - заполнение словаря из n элементов: O(1)
   Среднее время на заполнение одного элемента (приблизительный порядок):
   - список:  0.0049855709075927734
   - словарь: 0.006981849670410156
операция заполнения словоря занимает больше времени так как он представялет из себя Хеш-таблицу, 
но сложность обоих представляется как О(1), если только в список не вставлять число в начало, тогда по 
документации и скорости он имеет сложность O(n) 
"""


@time_decorator
def fill_list(lst, num):
    for i in range(num):
        lst.append(i)
    return f'Заполение списка'


print()
some_list = []
fill_list(some_list, n)
print('_' * 100)


@time_decorator
def fill_dict(dct, num):
    for i in range(num):
        dct[i] = i
    return f'Заполнение словоря'


print()
some_dict = {}
fill_dict(some_dict, n)
print('_' * 100)

"""
b)  Oценка:
   - получение элемента списка:  О(1) 
   - получение элемента словаря: O(1)
   Среднее время на заполнение одного элемента (приблизительный порядок):
   - список:  0.0010302066802978516
   - словарь: 0.0010006427764892578
   В теории время операции получения произвольного 
   (без поиска конкретного значения) элемента для списка (обращение к ячейки
   памяти по ее адресу) должно быть не больше, чем для словаря (обращение к
   нужному элементу по ключу)
"""


@time_decorator
def get_list(n, lst):
    for i in range(n):
        a = lst[i]
    return f'получение элемента списка'


@time_decorator
def get_dict(n, dict):
    for i in range(n):
        a = dct[i]
    return f'получение элемента словаря'


for i in range(1, 5):
    print(f'---------- n = {10**i:n} ----------')
    lst = [j for j in range(10**i)]
    get_list(10**i, lst)
    dct = {j: j for j in range(10 ** i)}
    get_dict(10**i, dct)
print()


"""
с) Оценка:
   - удаление элемента списка:  О(n) 
   - удаление элемента словаря: O(1)
   Среднее время на заполнение одного элемента :
   - список:  0.0009975433349609375
   - словарь: 0.0009970664978027344
   Время операции удалени элемента для списка должно быть больше, чем для словаря, для списка данная операция в среднем
   отрабатывает чуть медленнее.
"""


@time_decorator
def del_list(lst, n):
    for index, item in enumerate(n):
        del lst[0]
    return f'Удаления элемента списка'


@time_decorator
def del_dict(dct, n):
    for index, item in enumerate(n):
        del dct[i]
    return f'Удаления элемента словоря'


print('_' * 100)
for i in range(1, 5):
    print(f'---------- n = {10**i:n} ----------')
    del_list(10**i, [])
    del_dict(10**i, {})
print()





"""
Задание 2.
Ваша программа должна запрашивать пароль
Для этого пароля вам нужно вычислить хеш, используя алгоритм sha256
Для генерации хеша обязательно нужно использовать криптографическую соль
Обязательно выведите созданный хеш
Далее программа должна запросить пароль повторно и вновь вычислить хеш
Вам нужно проверить, совпадает ли пароль с исходным
Для проверки необходимо сравнить хеши паролей
ПРИМЕР:
Введите пароль: 123
В базе данных хранится строка: 555a3581d37993843efd4eba1921
f1dcaeeafeb855965535d77c55782349444b
Введите пароль еще раз для проверки: 123
Вы ввели правильный пароль
Важно: для хранения хеша и соли воспользуйтесь или файлом (CSV, JSON)
или, если вы уже знаете, как Python взаимодействует с базами данных,
воспользуйтесь базой данный sqlite, postgres и т.д.
п.с. статья на Хабре - python db-api
"""
import uuid
import hashlib
import json

def hash_password(password):
    # uuid используется для генерации случайного числа
    salt = uuid.uuid4().hex
    return hashlib.sha256(salt.encode() + password.encode()).hexdigest() + ':' + salt


def check_password(hashed_password, user_password):
    password, salt = hashed_password.split(':')
    return password == hashlib.sha256(salt.encode() + user_password.encode()).hexdigest()


new_pass = input('Введите пароль: ')
hashed_password = hash_password(new_pass)
print('Строка для хранения в базе данных: ' + hashed_password)
old_pass = input('Введите пароль еще раз для проверки: ')

if check_password(hashed_password, old_pass):
    print('Вы ввели правильный пароль')
else:
    print('Извините, но пароли не совпадают')

with open('personal.json', 'w') as json_file:
    json.dump(hash_password, json_file)

"""
Задание 3.
Определить количество различных (уникальных) подстрок
с использованием хеш-функции
Дана строка S длиной N, состоящая только из строчных латинских букв
Подсказка: вы должны в цикле для каждой подстроки вычислить хеш
Все хеши записываем во множество.
Оно отсечет дубли.
Экономия на размере хранимых данных (для длинных строк) и
скорость доступа вместе с уникальностью элементов,
которые даёт множество, сделают решение коротким и эффективным.
Пример:
рара - 6 уникальных подстрок
рар
ра
ар
ара
р
а
"""

import hashlib

pro_str = "papa"

check = set()
i = len(pro_str)

while i:
    for j in range(i):
        substr = pro_str[j:i].encode("utf-8")
        if len(substr) != len(pro_str):
            check.add(hashlib.sha256(substr).hexdigest())

    i -= 1

else:
    print(len(check))



"""
Задание 4.
Реализуйте скрипт "Кэширование веб-страниц"
Функция должна принимать url-адрес и проверять
есть ли в кэше соответствующая страница или нет
есть ли в кэше соответствующая страница или нет
Пример кэша: {'url-адрес': 'хеш url-а'; 'url-адрес': 'хеш url-а'; ...}
Если страница в кэше есть, просто вернуть значение хеша, например, 'хеш url-а'
Если страницы в кэше нет, то вычислить хеш и записать в кэш
Подсказка: задачу решите обязательно с применением 'соленого' хеширования
и одного из алгоритмов, например, sha512
Можете усложнить задачу, реализовав ее через ООП
"""


import hashlib


class UrlCache:

    salt = b'urls'

    def __init__(self):
        self.cache = {}

    def cache_check(self, url):
        if self.cache.get(url) is None:
            self.cache[url] = hashlib.sha256(self.salt + url.encode('utd-8')).hexdigest()
        else:
            print(f'cache {url}\n{self.cache[url]}')


cache = UrlCache()

cache.cache_check('yandex.ru')
cache.cache_check('mail.ru')
cache.cache_check('vk.com')
cache.cache_check('facebook.com')
