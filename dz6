"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для второго скрипта
"""

import numpy as np
from memory_profiler import profile

"""
1.3 Для ОПТИМИЗАЦИИ используем библиотеку NumPy
"""


# Курс 'Основы PYTHON'
# 10.1. Реализовать класс Matrix (матрица).

class Matrix:
    def __init__(self, matrix):
        self.matrix = matrix
        self.matrix_check()  # проверяем, что тип matrix list, все его эл-ты list и они равного размера
        self.m_rows = len(self.matrix)
        self.n_columns = len(self.matrix[0])

    def matrix_check(self):
        if type(self.matrix) is not list \
                or any(type(x) is not list for x in self.matrix) \
                or any(len(x) != len(self.matrix[0]) for x in self.matrix):
            raise ValueError('Invalid matrix')

    def get_matrix_dimension(self):
        return [self.m_rows, self.n_columns]

    def __str__(self):
        # конкатенация списков(sum) в строки (map); строка с макс. длиной(max); +2 пробела
        xx_max = len(max(list(map(str, sum(self.matrix, []))), key=len)) + 2  # длина поля для вывода значений матрицы
        s = '\n'.join([''.join([(str(i)).rjust(xx_max) for i in x]) for x in self.matrix])
        return f' матрица [{self.m_rows}x{self.n_columns}]\n{s}'

    def __add__(self, other):
        if self.get_matrix_dimension() != other.get_matrix_dimension():
            return None  # сложение матриц возможно только одной размерности
        return Matrix([[a + b for a, b in zip(row1, row2)] for row1, row2 in zip(self.matrix, other.matrix)])


"""
Используем NumPy для оптимизации Класса 
"""


class MatrixNP:
    def __init__(self, data):
        self.matrix = np.array(data) if isinstance(data, list) else data

    def __add__(self, other):
        return MatrixNP(self.matrix + other.matrix)

    def __str__(self):
        return '\n'.join([str(self.matrix[i]) for i in range(len(self.matrix))])


# Проверяем, что функционал одинаковый и под комментарий
# m0 = [[0, 3, 4], [100, 200, 400], [10, 20, 30], [-20, -40, -80]]
# m1 = [[10, 11, 12], [-20, -21, -22], [100, 200, 300], [100, 200, 300]]
# print(f'Old Class:\n{Matrix(m0)}\n+\n{Matrix(m1)}\n=\n{Matrix(m0) + Matrix(m1)}')
# print(f'New Class:\n{MatrixNP(m0)}\n+\n{MatrixNP(m1)}\n=\n{MatrixNP(m0) + MatrixNP(m1)}')


@profile
def matrix_test():
    x1 = Matrix(lst)
    x2 = Matrix(lst)
    x3 = x1 + x2
    return x3


@profile
def matrix_np_test():
    x1 = MatrixNP(lst)
    x2 = MatrixNP(lst)
    x3 = x1 + x2
    return x3


rows = 1000
column = 10000
lst = [list(range(column)) for _ in range(rows)]
matrix_test()
matrix_np_test()

"""
Не пользовался данной библиотекой NumPy. Но из документации прочитал что, поскольку пакет специализирован на экономном потреблении памяти при обработке больших данных, попробовал и действейтельно код оптимизировался.
"""
"""
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    99    406.0 MiB    406.0 MiB           1   @profile
   100                                         def matrix_test():
   101    406.0 MiB      0.0 MiB           1       x1 = Matrix(lst)
   102    406.0 MiB      0.0 MiB           1       x2 = Matrix(lst)
   103    789.9 MiB    384.0 MiB           1       x3 = x1 + x2
   104    789.9 MiB      0.0 MiB           1       return x3

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   107    410.1 MiB    410.1 MiB           1   @profile
   108                                         def matrix_np_test():
   109    448.2 MiB     38.1 MiB           1       x1 = MatrixNP(lst)
   110    486.4 MiB     38.1 MiB           1       x2 = MatrixNP(lst)
   111    524.5 MiB     38.2 MiB           1       x3 = x1 + x2
   112    524.5 MiB      0.0 MiB           1       return x3
"""

"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для третьего скрипта
"""
# Курс алгоритмы, урок 4, задание 1.

from memory_profiler import profile
from random import randint


# Исходная функция возвращает список
@profile
def original(nums):
    return [i for i in range(len(nums)) if nums[i] % 2 == 0]


# Оптимизированна функция возвращает генератор
@profile
def optimized(nums):
    return (i for i, x in enumerate(nums) if x % 2 == 0)


my_nums = [randint(1, 10000) for my_num in range(100000)]
original(my_nums)
optimized(my_nums)

"""
С использованием генератора память используемая функцией уменьшается
До:    24.8 MiB      1.5 MiB      100003       return [i for i in range(len(nums)) if nums[i] % 2 == 0]
После: 23.0 MiB      0.0 MiB           1       return (i for i, x in enumerate(nums) if x % 2 == 0)
"""
"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для четвертого скрипта
"""
# Курс алгоритмы, урок 2, задание 3.


from memory_profiler import memory_usage


def memor_dec(func):
    def wrapper(*args):
        start = memory_usage()
        res = func(*args)
        return f'Заняло пямяти = {memory_usage()[0] - start[0]}'

    return wrapper


@memor_dec
def original(nums, even=0, odd=0):
    if nums > 0:
        ev = nums % 10
        if ev % 2 == 0:
            even += 1
        else:
            odd += 1
        return original(nums // 10, even, odd)
    return even, odd


nums = int(123456789987654321123456789987654321123456789987654321123456789987654321)
print(original(nums))


@memor_dec
def optimized(enter_num, revers_num=''):
    while enter_num != 0:
        revers_num = revers_num + str(enter_num % 10)
        enter_num //= 10
    return revers_num


print(optimized(123456789987654321123456789987654321123456789987654321123456789987654321))

"""
Обычная замена рекурсии на цикл
До:    0.25390625 MiB
После: 0.0 MiB
"""
"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для пятого скрипта
"""

from memory_profiler import profile
# Заменил цикл на функцию map


@profile
def func_1():
    numbers = [i for i in range(10 ** 6)]
    result = []
    for num in numbers:
        result.append(float(num))
    return result


@profile
def func_2():
    return tuple(map(float, (i for i in range(10 ** 6))))


"""
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    25     19.1 MiB     19.1 MiB           1   @profile
    26                                         def func_2():
    27     58.1 MiB -28063.0 MiB     2000003       return tuple(map(float, (i for i in range(10 ** 6))))
"""


"""
Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
     4     19.1 MiB     19.1 MiB           1   @profile
     5                                         def func_1():
     6     58.6 MiB  -2346.7 MiB     1000003       numbers = [i for i in range(10 ** 6)]
     7     58.6 MiB      0.0 MiB           1       result = []
     8     95.7 MiB -43502.2 MiB     1000001       for num in numbers:
     9     95.7 MiB -43524.0 MiB     1000000           result.append(float(num))
"""
"""
Задание 2.
Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.
Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.
Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение.
"""
from memory_profiler import profile


@profile
def factorial(n):
    if n == 1:
        return n
    factorial(n - 1)


factorial(10)


@profile
def solution_func(n):
    return factorial(n)


solution_func(10)

"""
При рекурсии профилировщик делает замеры при каждом вызове рекурсии,
если обернуть эту функцию и сделать ее замер,то профилировщик памяти сделает замер один раз
"""
"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для первого скрипта
"""

"""
1.1 Для ОПТИМИЗАЦИИ используем СЛОТЫ в ООП 
"""


# Курс 'Основы PYTHON'
# 9.3. Реализовать базовый класс Worker (работник):
# определить атрибуты: name, surname, position (должность), income (доход);
# последний атрибут должен быть защищённым и ссылаться на словарь, содержащий элементы «оклад» и «премия»,
# например, {"wage": wage, "bonus": bonus};
# создать класс Position (должность) на базе класса Worker; в классе Position реализовать методы получения
# полного имени сотрудника (get_full_name) и дохода с учётом премии (get_total_income);
# проверить работу примера на реальных данных: создать экземпляры класса Position,
# передать данные, проверить значения атрибутов, вызвать методы экземпляров.


#1
class Worker:
    workers = []

    def __init__(self, name, surname, position, wage=0, bonus=0):
        self.name = name
        self.surname = surname
        self.position = position
        self.income = {"wage": wage, "bonus": bonus}
        Worker.workers.append(self)

    def get_full_name(self):
        return f'{self.name} {self.surname}'

    def get_total_income(self):
        return self.income["wage"] + self.income["bonus"]

    def __str__(self):
        return f'{self.get_full_name()} /{self.position}/ income: {self.get_total_income()}'

#2
class Employee:
    __slots__ = ['name', 'surname', 'position', 'income', 'wage', 'bonus']
    employees = []

    def __init__(self, name, surname, position, wage=0, bonus=0):
        self.name = name
        self.surname = surname
        self.position = position
        self.wage = wage
        self.bonus = bonus
        Employee.employees.append(self)

    def get_full_name(self):
        return f'{self.name} {self.surname}'

    def get_total_income(self):
        return self.wage + self.bonus

    def __str__(self):
        return f'{self.get_full_name()} /{self.position}/ income: {self.get_total_income()}'


# Проверка функционала
pos_1, pos_2 = Worker('Олег', 'Lee', 'waiter', 5000, 300), Worker('Катя', 'Fio', 'chef', 9000, 5000)
print(f'{Worker.workers[0]}\n{Worker.workers[1]}')
p_1, p_2 = Employee('Олег', 'Lee', 'waiter', 5000, 300), Employee('Катя', 'Fio', 'chef', 9000, 5000)
print(f'{Employee.employees[0]}\n{Employee.employees[1]}')


@profile
def old_class():
    for val in data:
        Worker(*val)
    return len(Worker.workers)


@profile
def opt_class():
    for val in data:
        Employee(*val)
    return len(Employee.employees)


number = 100000
data = [(f'Name{i}', f'LastN{i}', f'Position{i}', i * 100, i * 10) for i in range(number)]
print(old_class())
print(opt_class())

"""
Результаты тестов показали, что новый класс Employee заметно оптимизирован по памяти с помощью использования
конструкции __slots__ при определении класса, который заменяет затратные по памяти словари для хранения атрибутов
на менее затратные по памяти контейнеры – списки, кортежи.
Line  Mem usage  Increment   Occur   Line Contents        | Line  Mem usage  Increment   Occur   Line Contents   
===================================================       | ===================================================
  93   54.2 MiB   54.2 MiB       1   @profile             |  100   93.6 MiB   93.6 MiB       1   @profile
  94                                 def old_class():     |  101                                 def opt_class():
  95   93.5 MiB    0.0 MiB  100001       for val in data: |  102  102.1 MiB    0.0 MiB  100001       for val in data:
  96   93.5 MiB   39.3 MiB  100000           Worker(*val) |  103  102.1 MiB    8.6 MiB  100000           Employee(*val)
  97   93.6 MiB    0.0 MiB       1       return len       |  104  102.1 MiB    0.0 MiB       1       return len
"""
